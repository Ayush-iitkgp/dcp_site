{% extends "dcp_sandbox/base.html" %}
{% load staticfiles %}

{% block title %}Rules{% endblock %}

{% block page_content %}

<div class="span10">
<div class="span10">

<h2>Expressions</h2>

<p>Expressions in the <a href="/analyzer">DCP analyzer</a> and <a href="/quiz">quiz</a> are formed from the variables <code>x, y, z, u, v, w</code>, the parameters <code>a, b, c, d, e, f</code>, numerical constants such as <code>3</code> and <code>-2.44</code>, the standard arithmetic operators <code>+, -, *, /</code>, and a library of <a href="/functions">functions</a>. For simplicity, all expressions are scalar. Some examples are</p>

<pre><code>3.69 + b/3
x - 4*u
sqrt(x) - min(u, v - a)
max(2.66 - sqrt(u), square(x + 2*y))</code></pre>

<h2>Sign</h2>

<p>Each (sub)expression is flagged as <em>positive</em> (non-negative), <em>negative</em> (non-positive), or <em>unknown</em>. </p>

<p>The signs of larger expressions are determined from the signs of their subexpressions. For example, the sign of the expression <code>expr1*expr2</code> is</p>

<ul>
<li>Positive if <code>expr1</code> and <code>expr2</code> have the same (known) sign.</li>
<li>Negative if <code>expr1</code> and <code>expr2</code> have opposite (known) signs.</li>
<li>Unknown if either expression has unknown sign.</li>
</ul>

<p>The sign given to an expression is always correct. But DCP sign analysis may flag an expression as unknown sign when the sign could be figured out through more complex analysis. For instance, <code>x*x</code> has unknown sign by the rules above.</p>

<h2>Curvature</h2>

<p>Each (sub)expression is flagged as one of</p>

  <table class="table table-striped" style="font-size: 14;">
    <tr>
     <th></th>
     <th>Meaning</th>
    </tr>
    <tr>
      <td>constant</td>
      <td>$ f(x) $ independent of $ x $ </td>
    </tr>
    <tr>
      <td>affine</td>
      <td>$ f(\theta x + (1-\theta)y) = \theta f(x) + (1-\theta)f(y) $ </td>
    </tr>
    <tr>
      <td>convex</td>
      <td>$ f(\theta x + (1-\theta)y) \leq \theta f(x) + (1-\theta)f(y), \text{  } \forall \theta \in [0,1] $ </td>
    </tr>
    <tr>
      <td>concave</td>
      <td>$ f(\theta x + (1-\theta)y) \geq \theta f(x) + (1-\theta)f(y), \text{  } \forall \theta \in [0,1] $ </td>
    </tr>
    <tr>
      <td>unknown</td>
      <td>DCP analysis cannot determine the curvature</td>
    </tr>
  </table>

<p>using the curvature rules. As with sign analysis, the conclusion is always correct, but the simple analysis may miss expressions with known curvature.</p>

<h2>Curvature Rules</h2>

<p>$f(expr_1, expr_2, ..., expr_n)$ is convex if $\text{ } f$ is a convex function and for each $expr_{i}$ one of the following conditions holds:</p>

<ul>
<li>$f$ is increasing in argument i and $expr_{i}$ is convex.</li>
<li>$f$ is decreasing in argument i and $expr_{i}$ is concave.</li>
<li>$expr_{i}$ is affine or constant.</li>
</ul>

<p>$f(expr_1, expr_2, ..., expr_n)$ is concave if $\text{ } f$ is a concave function and for each $expr_{i}$ one of the following conditions holds:</p>

<ul>
<li>$f$ is increasing in argument i and $expr_{i}$ is concave.</li>
<li>$f$ is decreasing in argument i and $expr_{i}$ is convex.</li>
<li>$expr_{i}$ is affine or constant.</li>
</ul>

<p>If one of the $\text{ } expr_{i}$ does not satisfy any of the conditions, the curvature of $\text{ } f(expr_1, expr_2, ..., expr_n)$ is unknown.</p>

<p>Whether a function is increasing or decreasing may depend on the sign of the arguments. For instance, <code>square</code> is increasing for positive arguments and decreasing for negative arguments.</p>

<h2>Arithmetic Rules</h2>

<p>Arithmetic operators are affine functions, so both the rule for convex functions and the rule for concave functions apply.</p>

<p>DCP also imposes the following restrictions:</p>

<ul>
<li>You cannot multiply two non-constants. For example, <code>x*x</code> violates DCP.</li>
<li>You cannot divide by a non-constant. For example, <code>1/x</code> violates DCP.</li>
</ul>

<h2>Examples</h2>
<p>DCP analysis breaks expressions down into subexpressions. The tree visualization below shows how this works for the expression <code>2*square(x) + 3</code>:</p>

<p><img class="dcp-example" src="/static/dcp_sandbox/images/arith_expr.png" alt="2*square(x) + 3" title="" /></p>

<p>We'll walk through the application of the DCP rules to the expression <code>sqrt(1 + square(x))</code>.</p>

<p>The variable <code>x</code> has affine curvature and unknown sign. The <code>square</code> function is convex and non-monotone for arguments of unknown sign. It can take the affine expression <code>x</code> as an argument; the result <code>square(x)</code> is convex.</p>

<p>The arithmetic operator <code>+</code> is affine and increasing, so the composition <code>1 + square(x)</code> is convex by the curvature rule for convex functions. The atom <code>sqrt</code> is concave and increasing, which means it can only take a concave argument. Since <code>1 + square(x)</code> is convex, <code>sqrt(1 + square(x))</code> violates the DCP rules and cannot be verified as convex.</p>

<p>In fact, <code>sqrt(1 + square(x))</code> is convex. But to comply with the DCP rules we must rewrite the expression as <code>norm2(1, x)</code>, the L2 norm of the vector [1, x].</p>

<p>Here's the tree visualization for <code>sqrt(1 + square(x))</code>:</p>

<p><img class="dcp-example" src="/static/dcp_sandbox/images/invalid_expr.png" alt="sqrt(1 + square(x))" title="" /></p>

</div>

{% endblock %}